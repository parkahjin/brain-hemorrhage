# Brain Hemorrhage Detection - ìµœì  í•˜ì´í¼íŒŒë¼ë¯¸í„° ì •ë¦¬

## ğŸ“š ì¡°ì‚¬í•œ ì„±ê³µ ì‚¬ë¡€ ìš”ì•½

### 1. RSNA Kaggle Competition ì„±ê³µ ì‚¬ë¡€
- **ë°ì´í„°ì…‹**: RSNA Intracranial Hemorrhage Detection (72,516 train)
- **ëª¨ë¸**: ResNet50 fine-tuning
- **ë‹¬ì„± ì •í™•ë„**: 90%+

### 2. ì£¼ìš” ì—°êµ¬ ë…¼ë¬¸ë“¤
- Conv-LSTM + ResNet: 90% sensitivity, 80% accuracy
- Ensemble Deep Learning: 92% sensitivity, 70% specificity
- YOLOv5x-GCB: 93.1% mAP

---

## ğŸ¯ ìµœì  í•˜ì´í¼íŒŒë¼ë¯¸í„° ì„¤ì • (ì¢…í•©)

### **Learning Rate & Optimizer**
```python
# ì´ˆê¸° í•™ìŠµë¥ 
initial_lr = 5e-4  # 0.0005 (ì—¬ëŸ¬ ì„±ê³µ ì‚¬ë¡€ì—ì„œ ì‚¬ìš©)
# ë˜ëŠ”
initial_lr = 1e-4  # 0.0001 (conservative, ì•ˆì •ì )

# Optimizer
optimizer = Adam(learning_rate=initial_lr)

# Learning Rate Scheduler
ReduceLROnPlateau(
    monitor='val_loss',
    factor=0.5,        # LRì„ ì ˆë°˜ìœ¼ë¡œ ê°ì†Œ
    patience=3,        # 3 epochs ë™ì•ˆ ê°œì„  ì—†ìœ¼ë©´ ê°ì†Œ
    min_lr=1e-7,       # ìµœì†Œ í•™ìŠµë¥ 
    verbose=1
)
```

### **Training Configuration**
```python
epochs = 30              # ìš°ë¦¬ í”„ë¡œì íŠ¸ ëª©í‘œ
batch_size = 32          # ëŒ€ë¶€ë¶„ì˜ ì„±ê³µ ì‚¬ë¡€ ì‚¬ìš©
input_size = (224, 224)  # ë˜ëŠ” (128, 128) - ì†ë„ í–¥ìƒ
```

### **Data Augmentation (ê°•í™”ëœ ë²„ì „)**
```python
train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,           # 10Â° â†’ 20Â° ì¦ê°€
    width_shift_range=0.15,      # ìƒˆë¡œ ì¶”ê°€
    height_shift_range=0.15,     # ìƒˆë¡œ ì¶”ê°€
    horizontal_flip=True,
    vertical_flip=False,         # CTëŠ” ìƒí•˜ ë°˜ì „ ì•ˆí•¨
    zoom_range=0.2,              # 0.1 â†’ 0.2 ì¦ê°€
    brightness_range=[0.8, 1.2], # ìƒˆë¡œ ì¶”ê°€
    fill_mode='nearest'
)
```

### **Class Weights (í´ë˜ìŠ¤ ë¶ˆê· í˜• ì²˜ë¦¬)**
í˜„ì¬ ë°ì´í„°ì…‹:
- Train: hemorrhage 2,152 / normal 3,371
- ë¹„ìœ¨: 1 : 1.57

```python
# ë°©ë²• 1: Class Weights ê³„ì‚°
from sklearn.utils.class_weight import compute_class_weight

class_weights = {
    0: 3371 / (2152 + 3371),  # normal: 0.61
    1: 2152 / (2152 + 3371) * 1.5  # hemorrhage: 0.58 * 1.5 = 0.87 (ê°€ì¤‘ì¹˜ ê°•í™”)
}

# ë˜ëŠ” ê°„ë‹¨íˆ
class_weights = {0: 1.0, 1: 1.5}  # hemorrhageì— 1.5ë°° ê°€ì¤‘ì¹˜

# ë°©ë²• 2: Focal Loss (class imbalanceì— ë” íš¨ê³¼ì )
# ë‚˜ì¤‘ì— í•„ìš”ì‹œ êµ¬í˜„
```

### **Loss Function**
```python
# Binary Classification
loss = 'binary_crossentropy'

# ë˜ëŠ” Weighted Binary Crossentropy
# class_weights ì‚¬ìš©
```

### **Callbacks**
```python
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint

callbacks = [
    EarlyStopping(
        monitor='val_loss',
        patience=5,              # 3 â†’ 5 (epochs 30ì´ë¯€ë¡œ ì—¬ìœ )
        restore_best_weights=True,
        verbose=1
    ),
    ReduceLROnPlateau(
        monitor='val_loss',
        factor=0.5,
        patience=3,
        min_lr=1e-7,
        verbose=1
    ),
    ModelCheckpoint(
        filepath='best_model.h5',
        monitor='val_accuracy',
        save_best_only=True,
        verbose=1
    )
]
```

### **Fine-tuning ì „ëµ (2ë‹¨ê³„)**
```python
# ========== Stage 1: Freeze base model ==========
# Top layersë§Œ í•™ìŠµ (5 epochs)
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224,224,3))
for layer in base_model.layers:
    layer.trainable = False

# ... add top layers ...
model.compile(optimizer=Adam(1e-3), loss='binary_crossentropy', metrics=['accuracy'])
model.fit(..., epochs=5)

# ========== Stage 2: Unfreeze last conv block ==========
# ë§ˆì§€ë§‰ Conv block ì–¸í”„ë¦¬ì¦ˆ (25 epochs)
for layer in base_model.layers[-30:]:  # ë§ˆì§€ë§‰ 30ê°œ ë ˆì´ì–´
    layer.trainable = True

model.compile(optimizer=Adam(1e-4), loss='binary_crossentropy', metrics=['accuracy'])
model.fit(..., epochs=25)
```

---

## ğŸ“Š ì¶”ê°€ ê°œì„  ë°©ë²•

### 1. **Window Leveling (CT íŠ¹í™” ì „ì²˜ë¦¬)**
```python
def apply_brain_window(image):
    # Brain window: level=40, width=80
    # ë‡Œ ì¡°ì§ ê°•ì¡°
    window_center = 40
    window_width = 80
    img_min = window_center - window_width // 2
    img_max = window_center + window_width // 2
    image = np.clip(image, img_min, img_max)
    return image
```

### 2. **Test-Time Augmentation (TTA)**
ì¶”ë¡  ì‹œ ì—¬ëŸ¬ augmentation ë²„ì „ìœ¼ë¡œ ì˜ˆì¸¡ í›„ í‰ê· 
```python
# ì›ë³¸ + horizontal flip + rotation(-10, +10) ë“±
# 5ê°œ ë²„ì „ í‰ê·  â†’ ë” robustí•œ ì˜ˆì¸¡
```

### 3. **Mixed Precision Training**
Colab GPU ë©”ëª¨ë¦¬ ì ˆì•½ ë° ì†ë„ í–¥ìƒ
```python
from tensorflow.keras import mixed_precision
mixed_precision.set_global_policy('mixed_float16')
```

---

## ğŸ¯ ìš°ë¦¬ í”„ë¡œì íŠ¸ ìµœì¢… ê¶Œì¥ ì„¤ì •

```python
# Learning
initial_lr = 1e-4
optimizer = Adam
epochs = 30 (Stage 1: 5 + Stage 2: 25)
batch_size = 32

# Data
input_size = 224x224
augmentation = ê°•í™”ëœ ë²„ì „ (rotation 20Â°, shift 0.15, zoom 0.2, brightness)

# Class Balance
class_weights = {0: 1.0, 1: 1.5}

# Callbacks
EarlyStopping (patience=5)
ReduceLROnPlateau (factor=0.5, patience=3)
ModelCheckpoint (save best)

# Fine-tuning
2-stage approach
```

---

## ğŸ“Œ ì°¸ê³  ìë£Œ
- RSNA-Medical-Image-Detection: https://github.com/Pyligent/RSNA-Medical-Image-Detection
- PMC Research Papers: 3D CNN for ICH Detection, Transfer Learning Approaches
- Kaggle RSNA Intracranial Hemorrhage Detection Competition
